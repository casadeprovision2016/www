import { Request, Response, NextFunction } from 'express';
import { z, ZodSchema } from 'zod';
import DOMPurify from 'isomorphic-dompurify';

export const validateAndSanitize = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      // Log para debug
      console.log('üîç Validating request body:', JSON.stringify(req.body, null, 2));
      
      // Sanitizar strings no corpo da requisi√ß√£o
      const sanitized = sanitizeObject(req.body);
      
      // Validar com Zod
      const validated = schema.parse(sanitized);
      req.body = validated;
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.log('‚ùå Validation error:', error.errors);
        res.status(400).json({
          success: false,
          error: 'Dados de entrada inv√°lidos',
          details: error.errors.map(err => ({
            field: err.path.join('.'),
            message: err.message
          }))
        });
      } else {
        console.log('‚ùå Validation error (not Zod):', error);
        res.status(400).json({
          success: false,
          error: 'Erro na valida√ß√£o dos dados'
        });
      }
    }
  };
};

const sanitizeObject = (obj: any): any => {
  if (typeof obj === 'string') {
    return DOMPurify.sanitize(obj);
  }
  
  if (Array.isArray(obj)) {
    return obj.map(sanitizeObject);
  }
  
  if (obj !== null && typeof obj === 'object') {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeObject(value);
    }
    return sanitized;
  }
  
  return obj;
};

// Schemas de valida√ß√£o comuns
export const schemas = {
  // Eventos
  createEvent: z.object({
    title: z.string().min(1, 'T√≠tulo √© obrigat√≥rio').max(200, 'T√≠tulo muito longo'),
    description: z.string().max(2000, 'Descri√ß√£o muito longa').optional(),
    date: z.string().min(1, 'Data √© obrigat√≥ria'),
    time: z.string().min(1, 'Hora √© obrigat√≥ria'),
    location: z.string().max(200, 'Local muito longo').optional(),
    category: z.string().optional(), // Opcional pois n√£o existe na tabela
    capacity: z.number().int().positive().max(1000).optional()
  }),

  updateEvent: z.object({
    title: z.string().min(1).max(200).optional(),
    description: z.string().max(2000).optional(),
    date: z.string().min(1).optional(),
    time: z.string().min(1).optional(),
    location: z.string().max(200).optional(),
    category: z.string().optional(),
    capacity: z.number().int().positive().max(1000).optional()
  }),

  // Membros - Schema flex√≠vel para cria√ß√£o completa
  createMember: z.object({
    // Op√ß√£o 1: ID de usu√°rio existente
    user_id: z.string().uuid('ID do usu√°rio inv√°lido').optional(),
    
    // Op√ß√£o 2: Dados para criar novo usu√°rio
    name: z.string().min(1, 'Nome √© obrigat√≥rio').max(200).optional(),
    email: z.string().email('Email inv√°lido').optional(),
    phone: z.string().max(20).optional(),
    address: z.string().max(500).optional(),
    birthDate: z.string().optional(), // Data de nascimento
    
    // Dados espec√≠ficos do membro
    tipo_membro: z.enum(['efetivo', 'em_experiencia', 'congregado', 'visitante']).optional(),
    membership_type: z.enum(['efetivo', 'em_experiencia', 'congregado', 'visitante']).optional(),
    membershipType: z.enum(['efetivo', 'em_experiencia', 'congregado', 'visitante']).optional(), // Ingl√™s
    data_ingresso: z.string().optional(),
    join_date: z.string().optional(),
    joinDate: z.string().optional(), // Ingl√™s
    ministry: z.string().max(100).optional(),
    status: z.enum(['active', 'inactive', 'ativo', 'inativo']).optional(),
    observacoes: z.string().max(1000).optional(),
    notes: z.string().max(1000).optional()
  }).refine(data => {
    // Deve ter user_id OU dados para criar usu√°rio
    const hasUserId = data.user_id;
    const hasUserData = data.name && data.email;
    return hasUserId || hasUserData;
  }, {
    message: 'Deve fornecer user_id ou dados completos (name, email) para criar usu√°rio'
  }),

  updateMember: z.object({
    // Campos em portugu√™s (banco de dados)
    tipo_membro: z.enum(['efetivo', 'em_experiencia', 'congregado', 'visitante']).optional(),
    status: z.enum(['ativo', 'inativo']).optional(),
    observacoes: z.string().max(1000).optional(),
    batizado: z.boolean().optional(),
    data_batismo: z.string().optional(),
    dizimista: z.boolean().optional(),
    data_saida: z.string().optional(),
    
    // Campos em ingl√™s (frontend) - ser√£o mapeados no controller
    membershipType: z.enum(['efetivo', 'em_experiencia', 'congregado', 'visitante']).optional(),
    membership_type: z.enum(['efetivo', 'em_experiencia', 'congregado', 'visitante']).optional(),
    notes: z.string().max(1000).optional(),
    baptized: z.boolean().optional(),
    baptismDate: z.string().optional(),
    tithe: z.boolean().optional(),
    joinDate: z.string().optional(),
    endDate: z.string().optional(),
    end_date: z.string().optional()
  }),

  // Doa√ß√µes
  createDonation: z.object({
    user_id: z.string().uuid('ID do usu√°rio inv√°lido'),
    valor: z.number().positive('Valor deve ser positivo'),
    tipo: z.enum(['dizimo', 'oferta', 'missoes', 'outros']),
    descricao: z.string().max(500).optional(),
    data_doacao: z.string().datetime('Data da doa√ß√£o inv√°lida')
  }),

  // Informa√ß√µes de doa√ß√£o (dados banc√°rios)
  updateDonationInfo: z.object({
    iban: z.string().max(34).optional(),
    bic: z.string().max(11).optional(),
    titular: z.string().max(200).optional(),
    bizum: z.string().max(20).optional(),
    verse: z.string().max(200).optional(),
    additionalMethods: z.string().max(1000).optional(),
  }),

  // Streams
  createStream: z.object({
    // Campos em portugu√™s
    titulo: z.string().min(1, 'T√≠tulo √© obrigat√≥rio').max(200).optional(),
    descricao: z.string().max(1000).optional(),
    url_stream: z.string().min(1, 'URL da stream √© obrigat√≥ria').optional(),
    url_chat: z.string().optional(),
    data_inicio: z.string().min(1, 'Data de in√≠cio √© obrigat√≥ria').optional(),
    data_fim: z.string().optional().nullable(),
    status: z.enum(['agendado', 'ao_vivo', 'finalizado', 'cancelado']).optional(),
    evento_id: z.string().uuid().optional(),
    visualizacoes: z.number().int().min(0).optional(),
    gravacao_url: z.string().optional(),
    publico: z.boolean().optional(),
    senha: z.string().max(50).optional(),
    observacoes: z.string().optional(),
    // Campos em ingl√™s (para compatibilidade com frontend)
    title: z.string().min(1, 'Title √© obrigat√≥rio').max(200).optional(),
    description: z.string().max(1000).optional(),
    streamUrl: z.string().min(1, 'Stream URL √© obrigat√≥ria').optional(),
    chatUrl: z.string().optional(),
    startDate: z.string().min(1).optional(),
    endDate: z.string().optional().nullable(),
    scheduledDate: z.string().optional(),
    scheduledTime: z.string().optional(),
    platform: z.string().optional(),
    eventId: z.string().uuid().optional(),
    views: z.number().int().min(0).optional(),
    recordingUrl: z.string().optional(),
    public: z.boolean().optional(),
    password: z.string().max(50).optional(),
    notes: z.string().optional(),
  }).refine(data => {
    // Pelo menos titulo/title e url_stream/streamUrl devem estar presentes
    const hasTitle = data.titulo || data.title;
    const hasStreamUrl = data.url_stream || data.streamUrl;
    return hasTitle && hasStreamUrl;
  }, {
    message: 'T√≠tulo e URL da stream s√£o obrigat√≥rios'
  }),

  updateStream: z.object({
    // Campos em portugu√™s
    titulo: z.string().min(1).max(200).optional(),
    descricao: z.string().max(1000).optional(),
    url_stream: z.string().min(1).optional(),
    url_chat: z.string().optional(),
    data_inicio: z.string().min(1).optional(),
    data_fim: z.string().optional().nullable(),
    status: z.enum(['agendado', 'ao_vivo', 'finalizado', 'cancelado']).optional(),
    evento_id: z.string().uuid().optional(),
    visualizacoes: z.number().int().min(0).optional(),
    gravacao_url: z.string().optional(),
    publico: z.boolean().optional(),
    senha: z.string().max(50).optional(),
    observacoes: z.string().optional(),
    // Campos em ingl√™s (para compatibilidade com frontend)
    title: z.string().min(1).max(200).optional(),
    description: z.string().max(1000).optional(),
    streamUrl: z.string().min(1).optional(),
    chatUrl: z.string().optional(),
    startDate: z.string().min(1).optional(),
    endDate: z.string().optional().nullable(),
    scheduledDate: z.string().optional(),
    scheduledTime: z.string().optional(),
    platform: z.string().optional(),
    eventId: z.string().uuid().optional(),
    views: z.number().int().min(0).optional(),
    recordingUrl: z.string().optional(),
    public: z.boolean().optional(),
    password: z.string().max(50).optional(),
    notes: z.string().optional(),
  }),

  // Minist√©rios
  createMinistry: z.object({
    name: z.string().min(1, 'Nome √© obrigat√≥rio').max(100),
    descricao: z.string().max(1000).optional(),
    lider_id: z.string().uuid('ID do l√≠der inv√°lido')
  }),

  // Visitantes
  createVisitor: z.object({
    name: z.string().min(1, 'Nome √© obrigat√≥rio').max(255),
    email: z.string().email('Email inv√°lido').max(255).optional(),
    phone: z.string().max(50).optional(),
    address: z.string().optional(),
    visitDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Data deve estar no formato YYYY-MM-DD'),
    source: z.enum(['invitation', 'social_media', 'walk_in', 'website', 'other']).default('walk_in'),
    notes: z.string().optional(),
    followUpStatus: z.enum(['pending', 'contacted', 'scheduled', 'completed', 'no_interest']).default('pending'),
    followUpDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Data deve estar no formato YYYY-MM-DD').optional(),
    interestedInMembership: z.boolean().default(false),
  }),

  updateVisitor: z.object({
    name: z.string().min(1, 'Nome √© obrigat√≥rio').max(255).optional(),
    email: z.string().email('Email inv√°lido').max(255).optional(),
    phone: z.string().max(50).optional(),
    address: z.string().optional(),
    visitDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Data deve estar no formato YYYY-MM-DD').optional(),
    source: z.enum(['invitation', 'social_media', 'walk_in', 'website', 'other']).optional(),
    notes: z.string().optional(),
    followUpStatus: z.enum(['pending', 'contacted', 'scheduled', 'completed', 'no_interest']).optional(),
    followUpDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Data deve estar no formato YYYY-MM-DD').optional(),
    interestedInMembership: z.boolean().optional(),
  }),

  // Visitas Pastorais
  createPastoralVisit: z.object({
    visitado_id: z.string().uuid('ID do visitado inv√°lido'),
    pastor_id: z.string().uuid('ID do pastor inv√°lido'),
    data_visita: z.string().datetime('Data da visita inv√°lida'),
    motivo: z.string().max(500).optional(),
    observacoes: z.string().max(1000).optional()
  }),

  // Login
  login: z.object({
    email: z.string().email('Email inv√°lido'),
    password: z.string().min(6, 'Senha deve ter pelo menos 6 caracteres')
  }),

  // Query parameters
  pagination: z.object({
    page: z.coerce.number().int().positive().default(1),
    limit: z.coerce.number().int().positive().max(100).default(10),
    sort: z.string().optional(),
    order: z.enum(['asc', 'desc']).default('desc')
  }),

  eventQuery: z.object({
    upcoming: z.coerce.boolean().optional(),
    past: z.coerce.boolean().optional(),
    month: z.string().regex(/^\d{4}-\d{2}$/).optional(),
    year: z.string().regex(/^\d{4}$/).optional()
  }),

  donationQuery: z.object({
    tipo: z.enum(['dizimo', 'oferta', 'missoes', 'outros']).optional(),
    user_id: z.string().uuid().optional(),
    start_date: z.string().datetime().optional(),
    end_date: z.string().datetime().optional(),
    min_amount: z.coerce.number().positive().optional(),
    max_amount: z.coerce.number().positive().optional()
  })
};